<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kart Bros Ultra 3D â€“ Official Build</title>
    <style>
        body { margin: 0; overflow: hidden; background: #60a5fa; font-family: 'Arial Black', sans-serif; touch-action: none; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .hud { position: absolute; color: white; text-shadow: 4px 4px 0px #1e40af; font-style: italic; font-weight: 900; }
        #timer { top: 20px; font-size: 40px; }
        #speed { bottom: 30px; right: 30px; font-size: 60px; color: #fde047; }
        #lap { top: 20px; left: 20px; font-size: 30px; }
        #countdown { font-size: 200px; display: none; }
        #minimap-ui { position: absolute; bottom: 20px; left: 20px; width: 180px; height: 180px; background: rgba(0,0,0,0.4); border: 4px solid white; border-radius: 20px; }
    </style>
</head>
<body>
    <div id="ui">
        <div id="timer" class="hud">00:00.00</div>
        <div id="lap" class="hud">LAP 1/3</div>
        <div id="countdown" class="hud">3</div>
    </div>
    <div id="speed" class="hud">000 KM/H</div>
    <div id="minimap-ui"></div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- GLOBAL SETTINGS ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x60a5fa);
        scene.fog = new THREE.Fog(0x60a5fa, 40, 400);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.VSMShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const sun = new THREE.DirectionalLight(0xffffff, 1.5);
        sun.position.set(100, 200, 50);
        sun.castShadow = true;
        sun.shadow.camera.left = -200; sun.shadow.camera.right = 200;
        sun.shadow.camera.top = 200; sun.shadow.camera.bottom = -200;
        scene.add(sun);

        // --- TRACK GEOMETRY ---
        const trackPoints = [
            new THREE.Vector3(0, 0, 0), new THREE.Vector3(200, 0, 0),
            new THREE.Vector3(300, 0, 150), new THREE.Vector3(250, 0, 400),
            new THREE.Vector3(0, 0, 500), new THREE.Vector3(-250, 0, 400),
            new THREE.Vector3(-300, 0, 100), new THREE.Vector3(-150, 0, -100),
            new THREE.Vector3(0, 0, 0)
        ];
        const trackCurve = new THREE.CatmullRomCurve3(trackPoints);
        const roadWidth = 22;
        
        // Visual Road
        const roadGeo = new THREE.TubeGeometry(trackCurve, 128, roadWidth, 12, true);
        const roadMat = new THREE.MeshStandardMaterial({ color: 0x334155, roughness: 0.8 });
        const roadMesh = new THREE.Mesh(roadGeo, roadMat);
        roadMesh.position.y = -0.4;
        roadMesh.receiveShadow = true;
        scene.add(roadMesh);

        // Mountains (Boundaries)
        const landscape = new THREE.Group();
        const mountainGeo = new THREE.ConeGeometry(30, 80, 4);
        const mountainMat = new THREE.MeshStandardMaterial({ color: 0x166534 });
        for(let i=0; i<60; i++) {
            const m = new THREE.Mesh(mountainGeo, mountainMat);
            const ang = (i/60) * Math.PI * 2;
            const dist = 150 + Math.random() * 200;
            m.position.set(Math.cos(ang)*dist, 35, Math.sin(ang)*dist);
            m.castShadow = true;
            landscape.add(m);
        }
        scene.add(landscape);

        // --- STARTING PLACE ---
        const startLineGeo = new THREE.PlaneGeometry(roadWidth * 2, 5);
        const startLineMat = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        const startLine = new THREE.Mesh(startLineGeo, startLineMat);
        startLine.rotation.x = Math.PI / 2;
        startLine.position.set(0, 0.05, 0);
        scene.add(startLine);

        // --- KART PHYSICS ENGINE ---
        class Kart {
            constructor(color, isPlayer = false, startPos) {
                this.mesh = new THREE.Group();
                this.isPlayer = isPlayer;
                this.speed = 0;
                this.angle = 0;
                this.progress = 0;
                this.maxSpeed = isPlayer ? 1.6 : 1.4;

                // Body Construction
                const body = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 4), new THREE.MeshStandardMaterial({ color }));
                body.castShadow = true;
                this.mesh.add(body);
                
                // Spoiler
                const spoiler = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.3, 0.8), new THREE.MeshStandardMaterial({ color }));
                spoiler.position.set(0, 0.8, -1.5);
                this.mesh.add(spoiler);

                this.mesh.position.copy(startPos);
                scene.add(this.mesh);
            }

            update(keys) {
                if (this.isPlayer) {
                    if (keys['ArrowUp'] || keys['KeyW']) this.speed += 0.04;
                    if (keys['ArrowDown'] || keys['KeyS']) this.speed -= 0.04;
                    if (keys['ArrowLeft'] || keys['KeyA']) this.angle += 0.05 * Math.min(this.speed, 1);
                    if (keys['ArrowRight'] || keys['KeyD']) this.angle -= 0.05 * Math.min(this.speed, 1);

                    this.speed *= 0.97; // Drag
                    
                    // Collision: Boundary Logic
                    const nextX = this.mesh.position.x + Math.sin(this.angle) * this.speed;
                    const nextZ = this.mesh.position.z + Math.cos(this.angle) * this.speed;
                    
                    // Check distance to road center
                    const closestPoint = trackCurve.getPointAt(trackCurve.getUtoTmapping(0, this.progress));
                    const distToTrack = new THREE.Vector3(nextX, 0, nextZ).distanceTo(closestPoint);
                    
                    if (distToTrack < roadWidth) {
                        this.mesh.position.x = nextX;
                        this.mesh.position.z = nextZ;
                    } else {
                        this.speed *= 0.5; // Off-road slowdown / barrier bounce
                    }
                    this.mesh.rotation.y = this.angle;
                } else {
                    this.progress += 0.0008 + (Math.random() * 0.0002);
                    const pos = trackCurve.getPointAt(this.progress % 1);
                    this.mesh.position.lerp(pos, 0.1);
                    this.mesh.lookAt(trackCurve.getPointAt((this.progress + 0.01) % 1));
                }
            }
        }

        const player = new Kart(0xef4444, true, new THREE.Vector3(0, 0, -10));
        const bots = [
            new Kart(0x3b82f6, false, new THREE.Vector3(5, 0, -5)),
            new Kart(0xf59e0b, false, new THREE.Vector3(-5, 0, -5)),
            new Kart(0x8b5cf6, false, new THREE.Vector3(5, 0, 5)),
            new Kart(0x10b981, false, new THREE.Vector3(-5, 0, 5))
        ];

        // --- GAME LOOP & CONTROLS ---
        let gameStarted = false;
        const keys = {};
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        function startCountdown() {
            const el = document.getElementById('countdown');
            el.style.display = 'block';
            let c = 3;
            const timer = setInterval(() => {
                c--;
                el.innerText = c > 0 ? c : "GO!";
                if (c < 0) { clearInterval(timer); el.style.display = 'none'; gameStarted = true; }
            }, 1000);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (gameStarted) {
                player.update(keys);
                bots.forEach(b => b.update());

                // Smooth Pro Follow Camera
                const camPos = new THREE.Vector3(0, 6, -18).applyQuaternion(player.mesh.quaternion).add(player.mesh.position);
                camera.position.lerp(camPos, 0.1);
                camera.lookAt(player.mesh.position);

                document.getElementById('speed').innerText = Math.floor(player.speed * 180) + " KM/H";
            }
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        startCountdown();
        animate();
    </script>
</body>
</html>
